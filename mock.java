
interface Sort {
    shufflePiorCaso();
    shuffleMelhorCaso();
    sort();
}

class MergeSort implements Sort{
   shufflePiorCaso()

   shuffleMelhorCaso()

   sort()
}
   CustomList passwords;
   CustomList lengths;
   CustomList dates;   

   public CustomList {

   }

   private void generateCsv(String title, CustomList data){
      
      while(data.hasNext())

   }

   private String classifyPassword(String password) {
      //
      return "muito boa"
   }



   private void partOne (int[] arr, Sort sort){
      
      BufferReader bf = "path/to/file"

       

      const file = openFile("password_classifier.csv", "w");
      const file2 = openFile("password_classifier2.csv", "w");
      const file3 = openFile("password_fomartedData.csv", "w");



      let isGoodEnough = (str) => {

         return str === "Muito Boa" || str === "Boa"
      }

      while(bf.hasNext(){
         String str = bf.readLine();
         String[] list = str.split(",");

         password.add(list[1])
         lengths.add(list[2])
         dates.add(list[3])

         //password_classifier
         file.writeLine(list[1], classifyPassword(list[1]))

         //password_classifier2 filtered
         isGoodEnough(classifyPassword(list[1])) ? file2.writeLine(list[1], classifyPassword(list[1])) : ();

         //passwords_formated_data
         file3.writeLine(list[0], list[1], list[2], list[3].split(" ")[0].split("-").reverse().join("/"))
      })



      

   }

   class Resultado(){
	
}

class MergeSort() extends Resultados{
	lastEmbaralhamento=null
	sufferPiorCaso(){
		this.lastEmbaralhamento='PiorCaso'
	}
	sort(){
		super().begin_relatario()// salvar tempo atual
		ornenação com mergsort
		super().generate_relatorio(this.lastEmbaralhamento)// nome algoritimo,caso, tempo total
		//acrescer na ultima linha do csv o resultado.
	}
class InsertionSort() extends Resultados{
	lastEmbaralhamento=null
	sufferPiorCaso(){
		this.lastEmbaralhamento='PiorCaso'
	}
	